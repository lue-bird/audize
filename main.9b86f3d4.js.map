{"version":3,"sources":["virtual-audio.js","main.js"],"names":["defer","f","setTimeout","AudioContext","window","webkitAudioContext","VirtualAudioGraph","prepare","graph","key","base","forEach","node","i","type","connections","length","flatten","nodes","depth","diff","oldNodes","newNodes","patches","created","updated","removed","newNode","Object","values","oldNode","push","data","connection","split","j","Math","max","properties","oldProp","newProp","label","value","oldConnection","newConnection","constructor","context","opts","$context","$nodes","vPrev","autostart","resume","update","vGraph","vCurr","patch","_destroyNode","_removeProperty","_disconnect","_createNode","_setProperty","_connect","suspend","$node","createAnalyser","createBufferSource","destination","createBiquadFilter","createChannelMerger","createChannelSplitter","createConstantSource","createConvolver","maxDelayTime","find","createDelay","createDynamicsCompressor","createGain","feedforward","feedback","createIIRFilter","mediaElement","createMediaElementSource","document","querySelector","createMediaStreamDestination","createOscillator","createPanner","createStereoPanner","createWaveShaper","console","warn","prop","start","stop","disconnect","linearRampToValueAtTime","currentTime","method","target","time","default","a","b","param","connect","audio","addEventListener","state","App","Elm","Main","init","ports","updateAudio","subscribe"],"mappings":"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","file":"main.9b86f3d4.js","sourceRoot":"src","sourcesContent":["const defer = f => setTimeout(f, 0)\nconst AudioContext = window.AudioContext || window.webkitAudioContext\n\nexport default class VirtualAudioGraph {\n    // Static Methods ============================================================\n    //\n    static prepare(graph = []) {\n        // The first step in preparing the graph is to key each virtual node.\n        // This is how we perform a diff between graphs and calculate what has\n        // changed each update.\n        const key = (graph, base = '') => {\n            graph.forEach((node, i) => {\n                // RefNodes always have a key, and they also\n                // cannot have connections or properties\n                // so we can just return early and move on.\n                if (node.type === 'RefNode') return\n                // Assign the node a key if it didn't already have one.\n                // This is how we track changes to the graph in a slightly\n                // more organised way\n                if (!node.key) node.key = `${base}_${i}`\n\n                // Recursively assign keys to this nodes connections.\n                if (node.connections && node.connections.length > 0) {\n                    key(node.connections, node.key)\n                }\n            })\n\n            return graph\n        }\n\n        // It is often most natural to represent the audio graph as a list\n        // of trees, using RefNodes to \"jump\" between chains of node\n        // connections. This isns't the easiest data structure to deal with\n        // however, so the next step in preparation is the flatten the graph\n        // into a single array.\n        const flatten = (graph, nodes = {}, depth = 0) => {\n            graph.forEach((node, i) => {\n                // Don't push RefNodes to the flat graph.\n                if (node.type !== 'RefNode') nodes[node.key] = node\n                if (node.connections) flatten(node.connections, nodes, depth + 1)\n                // If we're deeper than the root of the graph, replace\n                // this node with a reference to itself by key.\n                if (depth > 0) graph[i] = { type: 'RefNode', key: node.key }\n            })\n\n            return nodes\n        }\n\n        return flatten(key(graph))\n    }\n\n    //\n    static diff(oldNodes, newNodes) {\n        const patches = { created: [], updated: [], removed: [] }\n\n        for (const newNode of Object.values(newNodes)) {\n            const oldNode = oldNodes[newNode.key]\n\n            // A node with newNode.key does not exist in the old graph, so this must\n            // mean we've created a brand new node.\n            if (!oldNode) {\n                patches.created.push({ type: 'node', key: newNode.key, data: newNode })\n\n                newNode.connections.forEach(connection => {\n                    patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\n                })\n\n                // A node with the same key exists in both graphs, but the type has changed\n                // (eg osc -> gain) so we need to recreate the node.\n            } else if (oldNode.type !== newNode.type) {\n                patches.updated.push({ type: 'node', key: newNode.key, data: newNode })\n\n                newNode.connections.forEach(connection => {\n                    patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\n                })\n\n                // A node with the same key exists in both graphs and the node hasn't\n                // fundamentally changed, so now we check whether properties or connections\n                // have changed.\n            } else {\n                // Checking properties...\n                for (let j = 0; j < Math.max(oldNode.properties.length, newNode.properties.length); j++) {\n                    const oldProp = oldNode.properties[j]\n                    const newProp = newNode.properties[j]\n\n                    //\n                    if (!oldProp) {\n                        patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\n                    } else if (!newProp) {\n                        patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\n                    } else if (oldProp.label !== newProp.label) {\n                        patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\n                        patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\n                    } else if (oldProp.value !== newProp.value) {\n                        patches.updated.push({ type: 'property', key: oldNode.key, data: newProp })\n                    }\n                }\n\n                // Checking connections...\n                for (let j = 0; j < Math.max(oldNode.connections.length, newNode.connections.length); j++) {\n                    const oldConnection = oldNode.connections[j]\n                    const newConnection = newNode.connections[j]\n\n                    //\n                    if (!oldConnection) {\n                        patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\n                    } else if (!newConnection) {\n                        patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\n                    } else if (oldConnection.key !== newConnection.key) {\n                        patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\n                        patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\n                    }\n                }\n            }\n\n            delete oldNodes[newNode.key]\n        }\n\n        for (const oldNode of Object.values(oldNodes)) {\n            patches.removed.push({ type: 'node', key: oldNode.key, data: oldNode })\n        }\n\n        return patches\n    }\n\n    // Constructor ===============================================================\n    //\n    constructor(context = new AudioContext(), opts = {}) {\n        // Borrowing a convetion from virtual dom libraries, the $ sign //is used to\n        // indicate \"real\" Web Audio bits, and the v- prefix is used to indicate\n        // virtual elements.\n\n        // $context is a reference to the `AudioContext` either passed in or created\n        // on construction.\n        this.$context = context\n        // A reference to the real graph of audio nodes\n        this.$nodes = {}\n        // We keep track of the prebious graph so we can perform a diff and work out\n        // what has changed between updates.\n        this.vPrev = {}\n\n        // In most modern browsers an Audio Context starts in a suspended state and\n        // requires some user interaction before it can be resumed. Still, we can\n        // attempt to resume the context ourselves in the developer passes in the\n        // `autostart` option.\n        if (opts.autostart) this.resume()\n    }\n\n    // Public Methods ============================================================\n    //\n    update(vGraph = []) {\n        // The accompanying library of virtual node functions\n        // encourages a nested tree-like approach to describing\n        // audio graphs. This isn't the easiest structure to deal\n        // with, however, so a preparation step serves to wrestle\n        // the graph into a more suitable shape.\n        const vCurr = VirtualAudioGraph.prepare(vGraph)\n\n        // A diff tracks everything that has been removed, created,\n        // and updated between updates. We perform this step so we\n        // only touch the audio nodes that need to be changed in some\n        // way.\n        const diff = VirtualAudioGraph.diff(this.vPrev, vCurr)\n\n        // Remove nodes and properties from the graph.\n        diff.removed.forEach(patch => {\n            switch (patch.type) {\n                case 'node':\n                    this._destroyNode(patch.key)\n                    break\n                case 'property':\n                    this._removeProperty(patch.key, patch.data)\n                    break\n                case 'connection':\n                    this._disconnect(patch.key, patch.data)\n                    break\n            }\n        })\n\n        // Create new nodes and add new properties to\n        // the graph.\n        diff.created.forEach(patch => {\n            switch (patch.type) {\n                case 'node':\n                    this._createNode(patch.key, patch.data)\n                    break\n                case 'property':\n                    this._setProperty(patch.key, patch.data)\n                    break\n                case 'connection':\n                    defer(() => this._connect(patch.key, patch.data))\n                    break\n            }\n        })\n\n        // Update existing nodes and properties in the\n        // graph.\n        diff.updated.forEach(patch => {\n            switch (patch.type) {\n                case 'node':\n                    this._destroyNode(patch.key)\n                    this._createNode(patch.key, patch.data)\n                    break\n                case 'property':\n                    this._setProperty(patch.key, patch.data)\n                    break\n                case 'connection':\n                    // Connections can't be updated\n                    break\n            }\n        })\n\n        // Store the current graph for next time.\n        this.vPrev = vCurr\n    }\n\n    // A thin wrapper of the `AudioContext.suspend()` method. This\n    // bassically exists so developers don't have to reach in and\n    // touch the \"real\" audio context directly.\n    suspend() {\n        this.$context.suspend()\n    }\n\n    // A thin wrapper of the `AudioContext.resume()` method. This\n    // bassically exists so developers don't have to reach in and\n    // touch the \"real\" audio context directly.\n    resume() {\n        this.$context.resume()\n    }\n\n    // Private Methods ===========================================================\n    //\n    _createNode(key, { type, properties }) {\n        let $node = null\n\n        //\n        switch (type) {\n            case 'AnalyserNode':\n                $node = this.$context.createAnalyser()\n                break\n            case 'AudioBufferSourceNode':\n                $node = this.$context.createBufferSource()\n                break\n            case 'AudioDestinationNode':\n                $node = this.$context.destination\n                break\n            case 'BiquadFilterNode':\n                $node = this.$context.createBiquadFilter()\n                break\n            case 'ChannelMergerNode':\n                $node = this.$context.createChannelMerger()\n                break\n            case 'ChannelSplitterNode':\n                $node = this.$context.createChannelSplitter()\n                break\n            case 'ConstantSourceNode':\n                $node = this.$context.createConstantSource()\n                break\n            case 'ConvolverNode':\n                $node = this.$context.createConvolver()\n                break\n            case 'DelayNode':\n                const maxDelayTime = properties.find(({ label }) => label === 'maxDelayTime')\n                $node = this.$context.createDelay((maxDelayTime && maxDelayTime.value) || 1)\n                break\n            case 'DynamicsCompressorNode':\n                $node = this.$context.createDynamicsCompressor()\n                break\n            case 'GainNode':\n                $node = this.$context.createGain()\n                break\n            case 'IIRFilterNode':\n                const feedforward = properties.find(({ label }) => label === 'feedforward')\n                const feedback = properties.find(({ label }) => label === 'feedback')\n                $node = this.$context.createIIRFilter(\n                    (feedforward && feedforward.value) || [0],\n                    (feedback && feedback.value) || [1]\n                )\n                break\n            case 'MediaElementAudioSourceNode':\n                const mediaElement = properties.find(({ label }) => label === 'mediaElement')\n                $node = this.$context.createMediaElementSource(\n                    document.querySelector(mediaElement.value)\n                )\n                break\n            case 'MediaStreamAudioDestinationNode':\n                $node = this.$context.createMediaStreamDestination()\n                break\n            // TODO: How should I handle creating / grabbing the media stream?\n            // case 'MediaStreamAudioSourceNode':\n            //   $node = this.$context.createMediaStreamSource(\n\n            //   )\n            //   break\n            case 'OscillatorNode':\n                $node = this.$context.createOscillator()\n                break\n            case 'PannerNode':\n                $node = this.$context.createPanner()\n                break\n            case 'StereoPannerNode':\n                $node = this.$context.createStereoPanner()\n                break\n            case 'WaveShaperNode':\n                $node = this.$context.createWaveShaper()\n                break\n            //\n            default:\n                console.warn(`Invalide node type of: ${type}. Defaulting to GainNode to avoid crashing the AudioContext.`)\n                $node = this.$context.createGain()\n        }\n\n        this.$nodes[key] = $node\n\n        //\n        properties.forEach(prop => this._setProperty(key, prop))\n\n        // Certain nodes like oscillators must be started before they will produce\n        // noise. We make the assumption that these nodes should always start\n        // immediately after they have been created, so if a `start` method exists we\n        // call it.\n        if ($node.start) $node.start()\n    }\n\n    //\n    _destroyNode(key) {\n        const $node = this.$nodes[key]\n\n        // Certain nodes like oscillators can be stopped. It probably doesn't make\n        // much of a difference calling this method, but we do just in case!\n        if ($node.stop) $node.stop()\n\n        // Calling disconnect with no arguments will disconnect this node from\n        // everything.\n        $node.disconnect()\n\n        // Finally remove the node from the graph and let the GC do its job.\n        delete this.$nodes[key]\n    }\n\n    //\n    _setProperty(key, { type, label, value }) {\n        const $node = this.$nodes[key]\n\n        switch (type) {\n            case 'NodeProperty':\n                $node[label] = value\n                break\n            case 'AudioParam':\n                $node[label].linearRampToValueAtTime(value, this.$context.currentTime + 0.01)\n                break\n            case 'ScheduledUpdate':\n                $node[label][value.method](value.target, value.time)\n                break\n        }\n    }\n\n    //\n    _removeProperty(key, { type, label, value }) {\n        const $node = this.$nodes[key]\n\n        switch (type) {\n            case 'NodeProperty':\n                break\n            case 'AudioParam':\n                $node[label].value = $node[label].default\n                break\n            case 'ScheduledUpdate':\n                // TODO: work out how to cancel scheduled updates\n                break\n        }\n    }\n\n    //\n    _connect(a, [b, param = null]) {\n        if (b) this.$nodes[a].connect(param ? this.$nodes[b][param] : this.$nodes[b])\n    }\n\n    //\n    _disconnect(a, [b, param = null]) {\n        if (b) this.$nodes[a].disconnect(param ? this.$nodes[b][param] : this.$nodes[b])\n    }\n}","/* global AudioContext */\nimport { Elm } from './Main.elm'\nimport VirtualAudioGraph from './virtual-audio'\n\nconst context = new AudioContext()\nconst audio = new VirtualAudioGraph(context)\n\n// Chrome autplay policy demans some user interaction\n// takes place before the AudioContext can be resumed.\nwindow.addEventListener('click', () => {\n\tif (context.state === 'suspended') context.resume()\n})\n\nconst App = Elm.Main.init({\n\tnode: document.querySelector('#app')\n})\n\nApp.ports.updateAudio.subscribe(graph => {\n\taudio.update(graph)\n})"]}